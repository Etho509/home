<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>JoP Pixel Art Generator</title>
<style>
  :root { --bg:#0b0f14; --panel:#121923; --muted:#8aa0b2; --text:#e7eef6; --acc:#2563eb; }
  *{box-sizing:border-box}
  body{
    margin:0; background:linear-gradient(135deg,#0f172a,#1e293b);
    color:var(--text); font:16px/1.45 ui-sans-serif,system-ui,Segoe UI,Inter,Roboto;
    min-height:100vh; display:flex; align-items:center; justify-content:center; padding:24px;
  }
  .card{
    width:min(1100px,100%); background:rgba(18,25,35,0.85);
    border:1px solid #1f2a36; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    backdrop-filter: blur(10px);
  }
  .pane{ padding:18px; }
  header{ display:flex; align-items:center; gap:14px; margin-bottom:8px; }
  .swatch{ width:40px; height:40px; border-radius:10px; background:linear-gradient(45deg,#2563eb,#38bdf8); border:1px solid #203048; }
  h1{ margin:0; font-size:20px; font-weight:800; }
  p.sub{ margin:.25rem 0 0; color:var(--muted) }
  .row{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
  @media (max-width:900px){ .row{ grid-template-columns:1fr } }
  label{ font-weight:600; font-size:14px }
  input[type="number"], input[type="file"], input[type="text"], select, button{
    width:100%; padding:12px 14px; border-radius:12px; border:1px solid #223041;
    background:#0e1420; color:var(--text);
  }
  .stack{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .muted{ color:var(--muted) }
  button{ cursor:pointer; background:linear-gradient(180deg,#3e8cff,#2b6fe0); border:1px solid #2d6fdd; font-weight:800 }
  button:disabled{ opacity:.6; cursor:not-allowed }
  .canvas-wrap{
    margin-top:12px; background:#0c131e; border:1px dashed #2a3b52; border-radius:12px; padding:14px;
    overflow:auto;
  }
  .toolbar { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-top:8px; }
  .toolbar .left, .toolbar .right { display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  code{ background:#0f1625;border:1px solid #1f2a36;border-radius:8px;padding:2px 6px }
  .pill{ display:inline-block; padding:4px 10px; border-radius:999px; border:1px solid #2a3b52; background:#0c131e; }
</style>
</head>
<body>
  <div class="card">
    <div class="pane">
      <header>
        <div class="swatch"></div>
        <div>
          <h1>JoP Pixel Art Generator</h1>
          <p class="sub">Upload an image → pick JoP canvas size (each canvas tile is <b>16×16</b> or <b>32×32</b>) → get a pixelated preview you can copy in-game.</p>
        </div>
      </header>

      <div class="row">
        <div>
          <label>Image</label>
          <input id="file" type="file" accept="image/*" />
          <div class="muted" style="margin-top:6px">Tip: square images work well; use “Cover/Contain” to fit.</div>
        </div>
        <div>
          <label>JoP Canvas Grid</label>
          <div class="stack">
            <span class="muted">Width (tiles)</span><input id="tilesW" type="number" min="1" max="64" value="4" style="max-width:110px">
            <span class="muted">Height (tiles)</span><input id="tilesH" type="number" min="1" max="64" value="3" style="max-width:110px">
            <span class="muted">Canvas type</span>
            <select id="tileSize" style="max-width:160px">
              <option value="16" selected>Standard (16×16)</option>
              <option value="32">Large (32×32)</option>
            </select>
            <span class="muted">Fit</span>
            <select id="fit" style="max-width:140px">
              <option value="contain" selected>Contain (letterbox)</option>
              <option value="cover">Cover (crop)</option>
              <option value="stretch">Stretch</option>
            </select>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div>
          <label>Preview & Export</label>
          <div class="stack">
            <span class="muted">Display scale</span><input id="scale" type="number" min="1" max="40" value="12" style="max-width:110px">
            <label class="stack"><input id="showTileGrid" type="checkbox" checked> <span class="muted">Tile grid</span></label>
            <label class="stack"><input id="showPixelGrid" type="checkbox"> <span class="muted">Pixel grid</span></label>
          </div>
        </div>
        <div>
          <label>&nbsp;</label>
          <div class="stack">
            <button id="renderBtn">Generate</button>
            <button id="downloadBtn" disabled>Download PNG</button>
          </div>
        </div>
      </div>

      <!-- Per-tile exporter controls -->
      <div class="row" style="margin-top:12px">
        <div>
          <label>Per-tile Export</label>
          <div class="stack">
            <span class="muted">Filename</span>
            <input id="tileName" type="text" value="jop_tile_{x}_{y}.png" style="max-width:260px">
            <span class="muted">(use {x},{y})</span>
          </div>
        </div>
        <div>
          <label>&nbsp;</label>
          <div class="stack">
            <button id="exportTilesBtn" disabled>Export Tiles (PNG)</button>
          </div>
        </div>
      </div>

      <div class="toolbar">
        <div class="left">
          <div class="pill">Output pixels: <code id="outSize">—</code></div>
          <div class="pill">Image fit: <code id="fitInfo">—</code></div>
          <div class="pill">Tile size: <code id="tileSizeInfo">16×16</code></div>
        </div>
        <div class="right muted" id="hoverInfo">Hover a pixel to see its color</div>
      </div>

      <div class="canvas-wrap">
        <canvas id="preview" tabindex="0" aria-label="Pixel preview"></canvas>
      </div>

      <div class="pane muted" style="font-size:13px">
        Notes: Output size = <b>(tilesW × tileSize)</b> by <b>(tilesH × tileSize)</b>. Tile size is 16 or 32 based on mode.
      </div>
    </div>
  </div>

<script>
(() => {
  const fileEl = document.getElementById('file');
  const tilesWEl = document.getElementById('tilesW');
  const tilesHEl = document.getElementById('tilesH');
  const tileSizeEl = document.getElementById('tileSize');
  const fitEl = document.getElementById('fit');
  const scaleEl = document.getElementById('scale');
  const showTileGridEl = document.getElementById('showTileGrid');
  const showPixelGridEl = document.getElementById('showPixelGrid');
  const renderBtn = document.getElementById('renderBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const exportTilesBtn = document.getElementById('exportTilesBtn');
  const tileNameEl = document.getElementById('tileName');
  const outSizeEl = document.getElementById('outSize');
  const fitInfoEl = document.getElementById('fitInfo');
  const tileSizeInfoEl = document.getElementById('tileSizeInfo');
  const hoverInfoEl = document.getElementById('hoverInfo');
  const canvas = document.getElementById('preview');
  const ctx = canvas.getContext('2d');

  let sourceImg = null;
  let lastOffscreen = null;
  let lastScale = 12;
  let lastTileSize = 16;

  const clamp = (v,min,max) => Math.max(min, Math.min(max,v));
  const toHex = (r,g,b) => '#'+[r,g,b].map(v=>v.toString(16).toUpperCase().padStart(2,'0')).join('');
  const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));

  function loadImage(file){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  function computeFit(srcW, srcH, dstW, dstH, mode){
    if(mode==='stretch') return { sx:0, sy:0, sw:srcW, sh:srcH, dx:0, dy:0, dw:dstW, dh:dstH, info:'stretch' };
    const srcAR = srcW/srcH;
    const dstAR = dstW/dstH;
    if(mode==='contain'){
      let dw, dh;
      if(srcAR > dstAR){ dw = dstW; dh = Math.round(dstW/srcAR); }
      else { dh = dstH; dw = Math.round(dstH*srcAR); }
      const dx = Math.floor((dstW - dw)/2), dy = Math.floor((dstH - dh)/2);
      return { sx:0, sy:0, sw:srcW, sh:srcH, dx, dy, dw, dh, info:'contain (letterbox)' };
    }else{
      let sw, sh, sx, sy;
      if(srcAR > dstAR){
        sh = srcH; sw = Math.round(dstAR*sh);
        sx = Math.floor((srcW - sw)/2); sy = 0;
      }else{
        sw = srcW; sh = Math.round(sw/dstAR);
        sx = 0; sy = Math.floor((srcH - sh)/2);
      }
      return { sx, sy, sw, sh, dx:0, dy:0, dw:dstW, dh:dstH, info:'cover (crop)' };
    }
  }

  function render(){
    if(!sourceImg){ alert('Please choose an image first.'); return; }

    const tilesW = clamp(parseInt(tilesWEl.value||'4',10), 1, 64);
    const tilesH = clamp(parseInt(tilesHEl.value||'3',10), 1, 64);
    const tileSize = parseInt(tileSizeEl.value||'16',10);
    lastTileSize = tileSize;
    tileSizeInfoEl.textContent = `${tileSize}×${tileSize}`;

    const outW = tilesW*tileSize, outH = tilesH*tileSize;

    // Offscreen true-size canvas
    const off = document.createElement('canvas');
    off.width = outW; off.height = outH;
    const octx = off.getContext('2d', { willReadFrequently:true });
    octx.imageSmoothingEnabled = false;
    ctx.imageSmoothingEnabled = false;

    const fitMode = fitEl.value;
    const fit = computeFit(sourceImg.naturalWidth, sourceImg.naturalHeight, outW, outH, fitMode);
    octx.clearRect(0,0,outW,outH);
    octx.drawImage(sourceImg, fit.sx, fit.sy, fit.sw, fit.sh, fit.dx, fit.dy, fit.dw, fit.dh);

    lastOffscreen = off;
    outSizeEl.textContent = `${outW} × ${outH}`;
    fitInfoEl.textContent = fit.info;

    const scale = clamp(parseInt(scaleEl.value||'12',10), 1, 40);
    lastScale = scale;
    canvas.width = outW * scale;
    canvas.height = outH * scale;

    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(off, 0, 0, canvas.width, canvas.height);

    // Grids
    if(showPixelGridEl.checked || showTileGridEl.checked){
      ctx.save();
      if(showPixelGridEl.checked){
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        for(let x=0; x<=outW; x++){
          ctx.beginPath(); ctx.moveTo(x*scale+0.5,0); ctx.lineTo(x*scale+0.5,canvas.height); ctx.stroke();
        }
        for(let y=0; y<=outH; y++){
          ctx.beginPath(); ctx.moveTo(0,y*scale+0.5); ctx.lineTo(canvas.width,y*scale+0.5); ctx.stroke();
        }
      }
      if(showTileGridEl.checked){
        ctx.strokeStyle = 'rgba(56,189,248,0.65)';
        ctx.lineWidth = 2;
        for(let x=0; x<=outW; x+=tileSize){
          ctx.beginPath(); ctx.moveTo(x*scale+1,0); ctx.lineTo(x*scale+1,canvas.height); ctx.stroke();
        }
        for(let y=0; y<=outH; y+=tileSize){
          ctx.beginPath(); ctx.moveTo(0,y*scale+1); ctx.lineTo(canvas.width,y*scale+1); ctx.stroke();
        }
      }
      ctx.restore();
    }

    downloadBtn.disabled = false;
    exportTilesBtn.disabled = false;
  }

  function downloadPNG(){
    if(!lastOffscreen){ return; }
    const a = document.createElement('a');
    a.download = 'jop-pixel-art.png';
    a.href = lastOffscreen.toDataURL('image/png');
    a.click();
  }

  async function exportTiles(){
    if(!lastOffscreen) return;
    const outW = lastOffscreen.width;
    const outH = lastOffscreen.height;
    const tileSize = lastTileSize;

    const tilesX = Math.floor(outW / tileSize);
    const tilesY = Math.floor(outH / tileSize);
    const namePattern = (tileNameEl.value || 'jop_tile_{x}_{y}.png').trim();

    const tileCanvas = document.createElement('canvas');
    tileCanvas.width = tileSize; tileCanvas.height = tileSize;
    const tctx = tileCanvas.getContext('2d', { willReadFrequently:true });
    tctx.imageSmoothingEnabled = false;

    const THROTTLE_MS = 40;

    for(let ty=0; ty<tilesY; ty++){
      for(let tx=0; tx<tilesX; tx++){
        tctx.clearRect(0,0,tileSize,tileSize);
        tctx.drawImage(lastOffscreen, tx*tileSize, ty*tileSize, tileSize, tileSize, 0, 0, tileSize, tileSize);
        const url = tileCanvas.toDataURL('image/png');
        const a = document.createElement('a');
        const fname = namePattern.replace('{x}', String(tx)).replace('{y}', String(ty));
        a.download = fname;
        a.href = url;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        // eslint-disable-next-line no-await-in-loop
        await sleep(THROTTLE_MS);
      }
    }
  }

  // Hover color readout
  canvas.addEventListener('mousemove', (e)=>{
    if(!lastOffscreen) { hoverInfoEl.textContent = 'Hover a pixel to see its color'; return; }
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / lastScale);
    const y = Math.floor((e.clientY - rect.top) / lastScale);
    const outW = lastOffscreen.width, outH = lastOffscreen.height;
    if(x<0 || y<0 || x>=outW || y>=outH){ hoverInfoEl.textContent = 'Hover a pixel to see its color'; return; }
    const octx = lastOffscreen.getContext('2d', { willReadFrequently:true });
    const data = octx.getImageData(x,y,1,1).data;
    const hex = toHex(data[0], data[1], data[2]);

    const tileSize = lastTileSize;
    const tileX = Math.floor(x/tileSize), tileY = Math.floor(y/tileSize);
    hoverInfoEl.innerHTML = `Pixel <code>${x},${y}</code> · Tile <code>${tileX},${tileY}</code> · <code>${hex}</code>`;
  });

  // Wire up
  const renderIfReady = ()=>{ if(sourceImg) render(); };

  fileEl.addEventListener('change', async ()=>{
    const f = fileEl.files && fileEl.files[0];
    if(!f) return;
    sourceImg = await loadImage(f);
    render();
  });
  renderBtn.addEventListener('click', render);
  downloadBtn.addEventListener('click', downloadPNG);
  exportTilesBtn.addEventListener('click', exportTiles);

  [tilesWEl, tilesHEl, tileSizeEl, fitEl, scaleEl, showTileGridEl, showPixelGridEl].forEach(el=>{
    el.addEventListener('change', renderIfReady);
  });
})();
</script>
</body>
</html>
